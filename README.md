# Self-Healing Time Parser

A self-healing time parser system that uses an LLM-based coding agent to automatically update parsing logic when encountering new time expression patterns. The system learns from failures and improves itself without manual intervention.

## The Story

### The Problem

Natural language time expressions are notoriously difficult to parse programmatically. Users might say:
- "tomorrow"
- "next week"
- "in 2 days"
- "Monday morning"
- "By 9 AM on Friday"
- "within 1-2 business days"

Too many variations exist for manual coding, yet too few for full LLM overkill on every parse. Traditional parsers fail on new patterns, requiring constant manual updates.

### The Solution

This system implements a **self-healing architecture** that:

1. **Captures Failures**: When the parser encounters an unparseable time expression, it logs the error to a queue
2. **Clusters Errors**: An LLM-based agent analyzes accumulated errors and groups them by semantic similarity
3. **Generates Code**: The agent designs and implements new parser modules for each error cluster
4. **Validates**: Comprehensive tests are generated and run to ensure correctness
5. **Self-Updates**: The parser automatically reloads with new capabilities
6. **Cleans Up**: Processed errors are removed from the queue

The system improves itself without manual intervention, learning from real-world usage patterns.

## How It Works

The system uses a **REASON → PLAN → ACT → VALIDATE** workflow pattern:

```
┌─────────┐
│ REASON  │ → Cluster errors by semantic similarity
└────┬────┘
     │
┌────▼────┐
│  PLAN   │ → Design parsing strategies for each cluster
└────┬────┘
     │
┌────▼────┐
│   ACT   │ → Generate parser modules and test files
└────┬────┘
     │
┌────▼────┐
│VALIDATE │ → Run tests, retry if needed
└────┬────┘
     │
     ├─→ Tests Pass? → Update Parser → Remove Errors
     │
     └─→ Tests Fail? → Retry (up to 3 attempts)
```

### Key Components

- **TimeParser**: Main orchestrator that dynamically loads cluster-specific parser modules
- **Exception Interceptor**: Captures parsing failures and logs them to an error queue
- **Coding Agent Workflow**: LLM-powered agent that generates code using Google Gemini 3
- **Dynamic Module Loading**: Parser modules are discovered and loaded at runtime
- **Test-Driven Validation**: Every generated module includes comprehensive pytest tests

## Quick Start

### Prerequisites

- Python 3.11+
- Jupyter Notebook
- Google Gemini API key (set as environment variable or in configuration)

### Running the Demo

The complete story is demonstrated in the interactive Jupyter notebook:

```bash
# Navigate to the project directory
cd /path/to/agi_house_gemini_3_hackathon_12132025

# Launch Jupyter Notebook
jupyter notebook notebooks/demo.ipynb
```

**Or using uv:**

```bash
uv run jupyter notebook notebooks/demo.ipynb
```

### What You'll See

The notebook walks through the complete self-healing cycle:

1. **Problem Demonstration**: See the parser fail on various time expressions
2. **Error Collection**: Watch as failures are captured in the error queue
3. **Agent Activation**: Observe the LLM agent:
   - **REASON**: Cluster errors by similarity
   - **PLAN**: Design parsing strategies
   - **ACT**: Generate Python modules and tests
   - **VALIDATE**: Run tests and verify correctness
4. **Success Verification**: Confirm the parser now handles previously failing inputs
5. **Production Data**: Optional section for real-world validation

## Architecture

### Directory Structure

```
.
├── time_parser/
│   ├── parser.py              # Main orchestrator
│   ├── wrapper.py             # Exception interceptor
│   ├── parsers/               # Cluster-specific modules (generated by agent)
│   │   ├── relative_time_offsets.py
│   │   ├── weekday_time_constraints.py
│   │   └── business_day_ranges.py
│   └── tests/                 # Test files (generated by agent)
│       ├── test_relative_time_offsets.py
│       ├── test_weekday_time_constraints.py
│       └── test_business_day_ranges.py
├── coding_agent/
│   ├── agent.py               # CodingAgentWorkflow (REASON/PLAN/ACT/VALIDATE)
│   ├── error_queue.py         # Error queue management
│   ├── test_runner.py         # Pytest integration
│   ├── reloader.py            # Dynamic module reloading
│   └── cleanup.py             # Stale test file cleanup
├── notebooks/
│   └── demo.ipynb             # Interactive demonstration
└── README.md                  # This file
```

### Workflow Details

**REASON Node**: Uses LLM to analyze error patterns and cluster them by semantic similarity. Selects up to 5 clusters for processing.

**PLAN Node**: For each selected cluster, designs:
- Parsing strategy (regex patterns, dateutil usage, etc.)
- Code structure
- Test cases
- Edge cases to handle

**ACT Node**: Generates complete Python code:
- Parser module with `parse(text: str) -> datetime | None` function
- Comprehensive test file with parameterized pytest tests
- All code is syntactically correct and ready to execute

**VALIDATE Node**: 
- Runs pytest on generated tests
- Retries up to 3 times if tests fail
- On success: removes processed errors from queue and reloads parser
- On failure: logs failed batch for later analysis

## Features

- ✅ **Automatic Error Detection**: Captures parsing failures without blocking execution
- ✅ **Intelligent Clustering**: Groups similar errors for efficient code generation
- ✅ **Modular Architecture**: One parser module per error cluster
- ✅ **Test-Driven**: Every module includes comprehensive tests
- ✅ **Self-Updating**: Parser reloads with new capabilities automatically
- ✅ **Retry Logic**: Handles test failures with intelligent retries
- ✅ **Production Ready**: Handles real-world error patterns

## Example Output

After running the agent workflow, the parser can handle expressions like:

```python
from time_parser.parser import TimeParser

parser = TimeParser()

# These all work after agent updates:
parser.parse("tomorrow")                    # ✅
parser.parse("next week")                   # ✅
parser.parse("in 2 days")                  # ✅
parser.parse("Monday morning")              # ✅
parser.parse("By 9 AM on Friday")           # ✅
parser.parse("within 1-2 business days")    # ✅
```

## Technical Highlights

- **LangGraph Workflow**: Uses LangGraph for stateful, multi-step agent workflows
- **Google Gemini 3**: Powered by Google's latest Gemini model via LangChain
- **Dynamic Module Loading**: Python's `importlib` for runtime code updates
- **Robust JSON Parsing**: Handles LLM responses with explanatory text and markdown
- **Absolute Path Handling**: Works correctly regardless of execution directory
- **Error Recovery**: Graceful handling of stale modules and test files

## Learn More

For detailed technical documentation, see:
- `Documentation/design_assessment.md` - Complete architecture and design decisions
- `Documentation/development_plan_sprint_1.mdx` - Implementation plan and specifications

## Run the Notebook

**The best way to understand this system is to see it in action:**

```bash
jupyter notebook notebooks/demo.ipynb
```

The notebook provides an interactive walkthrough of the entire self-healing cycle, from initial failures through agent-generated solutions to verified success.

---

**Built for AGI House Gemini 3 Hackathon - December 2025**
